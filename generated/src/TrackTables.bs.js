// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Spice = require("@greenlabs/ppx-spice/src/rescript/Spice.bs.js");
var EnvSafe = require("rescript-envsafe/src/EnvSafe.bs.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Logging = require("./Logging.bs.js");
var EnvUtils = require("./EnvUtils.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

globalThis.fetch = require('node-fetch')
;

var envSafe = EnvSafe.make(undefined, undefined);

var hasuraGraphqlEndpoint = EnvUtils.getStringEnvVar("http://localhost:8080/v1/metadata", envSafe, "HASURA_GRAPHQL_ENDPOINT");

var hasuraRole = EnvUtils.getStringEnvVar("admin", envSafe, "HASURA_GRAPHQL_ROLE");

var hasuraSecret = EnvUtils.getStringEnvVar("testing", envSafe, "HASURA_GRAPHQL_ADMIN_SECRET");

var headers = {
  "Content-Type": "application/json",
  "X-Hasura-Role": hasuraRole,
  "X-Hasura-Admin-Secret": hasuraSecret
};

function hasuraErrorResponse_encode(v) {
  return Js_dict.fromArray(Spice.filterOptional([
                  [
                    "code",
                    false,
                    Spice.stringToJson(v.code)
                  ],
                  [
                    "error",
                    false,
                    Spice.stringToJson(v.error)
                  ],
                  [
                    "path",
                    false,
                    Spice.stringToJson(v.path)
                  ]
                ]));
}

function hasuraErrorResponse_decode(v) {
  var dict = Js_json.classify(v);
  if (typeof dict === "number") {
    return Spice.error(undefined, "Not an object", v);
  }
  if (dict.TAG !== /* JSONObject */2) {
    return Spice.error(undefined, "Not an object", v);
  }
  var dict$1 = dict._0;
  var code = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "code"), null));
  if (code.TAG === /* Ok */0) {
    var error = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "error"), null));
    if (error.TAG === /* Ok */0) {
      var path = Spice.stringFromJson(Belt_Option.getWithDefault(Js_dict.get(dict$1, "path"), null));
      if (path.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: {
                  code: code._0,
                  error: error._0,
                  path: path._0
                }
              };
      }
      var e = path._0;
      return {
              TAG: /* Error */1,
              _0: {
                path: ".path" + e.path,
                message: e.message,
                value: e.value
              }
            };
    }
    var e$1 = error._0;
    return {
            TAG: /* Error */1,
            _0: {
              path: ".error" + e$1.path,
              message: e$1.message,
              value: e$1.value
            }
          };
  }
  var e$2 = code._0;
  return {
          TAG: /* Error */1,
          _0: {
            path: ".code" + e$2.path,
            message: e$2.message,
            value: e$2.value
          }
        };
}

function validateHasuraResponse(statusCode, responseJson) {
  if (statusCode === 200) {
    return {
            TAG: /* Ok */0,
            _0: /* QuerySucceeded */0
          };
  }
  var decoded = hasuraErrorResponse_decode(responseJson);
  if (decoded.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: undefined
          };
  }
  var match = decoded._0.code;
  switch (match) {
    case "already-exists" :
    case "already-tracked" :
        return {
                TAG: /* Ok */0,
                _0: /* AlreadyDone */1
              };
    default:
      return {
              TAG: /* Error */1,
              _0: undefined
            };
  }
}

async function clearHasuraMetadata(param) {
  var body = {
    type: "clear_metadata",
    args: {}
  };
  var response = await fetch(hasuraGraphqlEndpoint, {
        method: "POST",
        body: Caml_option.some(Belt_Option.getExn(JSON.stringify(body))),
        headers: Caml_option.some(new Headers(headers))
      });
  var responseJson = await response.json();
  var statusCode = response.status;
  var $$case = validateHasuraResponse(statusCode, responseJson);
  if ($$case.TAG !== /* Ok */0) {
    return Logging.error({
                msg: "EE806: There was an issue clearing metadata in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                requestStatusCode: statusCode,
                requestResponseJson: responseJson
              });
  }
  var msg = $$case._0 ? "Metadata Already Cleared" : "Metadata Cleared";
  return Logging.trace({
              msg: msg,
              requestStatusCode: statusCode,
              requestResponseJson: responseJson
            });
}

async function trackTable(tableName) {
  var body = {
    type: "pg_track_table",
    args: {
      source: "public",
      schema: "public",
      name: tableName
    }
  };
  var response = await fetch(hasuraGraphqlEndpoint, {
        method: "POST",
        body: Caml_option.some(Belt_Option.getExn(JSON.stringify(body))),
        headers: Caml_option.some(new Headers(headers))
      });
  var responseJson = await response.json();
  var statusCode = response.status;
  var $$case = validateHasuraResponse(statusCode, responseJson);
  if ($$case.TAG !== /* Ok */0) {
    return Logging.error({
                msg: "EE807: There was an issue tracking the " + tableName + " table in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableName: tableName,
                requestStatusCode: statusCode,
                requestResponseJson: responseJson
              });
  }
  var msg = $$case._0 ? "Table Already Tracked" : "Table Tracked";
  return Logging.trace({
              msg: msg,
              tableName: tableName,
              requestStatusCode: statusCode,
              requestResponseJson: responseJson
            });
}

async function createSelectPermissions(tableName) {
  var body = {
    type: "pg_create_select_permission",
    args: {
      table: tableName,
      role: "public",
      source: "default",
      permission: {
        columns: "*",
        filter: {}
      }
    }
  };
  var response = await fetch(hasuraGraphqlEndpoint, {
        method: "POST",
        body: Caml_option.some(Belt_Option.getExn(JSON.stringify(body))),
        headers: Caml_option.some(new Headers(headers))
      });
  var responseJson = await response.json();
  var statusCode = response.status;
  var $$case = validateHasuraResponse(statusCode, responseJson);
  if ($$case.TAG !== /* Ok */0) {
    return Logging.error({
                msg: "EE808: There was an issue setting up view permissions for the " + tableName + " table in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableName: tableName,
                requestStatusCode: statusCode,
                requestResponseJson: responseJson
              });
  }
  var msg = $$case._0 ? "Hasura select permissions already created" : "Hasura select permissions created";
  return Logging.trace({
              msg: msg,
              tableName: tableName,
              requestStatusCode: statusCode,
              requestResponseJson: responseJson
            });
}

async function createEntityRelationship(tableName, relationshipType, relationalKey, mappedEntity, derivedFromFieldKey) {
  var derivedFromTo = derivedFromFieldKey !== "" ? "\"id\": \"" + derivedFromFieldKey + "\"" : "\"" + relationalKey + "\" : \"id\"";
  var bodyString = "{\"type\": \"pg_create_" + relationshipType + "_relationship\",\"args\": {\"table\": \"" + tableName + "\",\"name\": \"" + relationalKey + "Map\",\"source\": \"default\",\"using\": {\"manual_configuration\": {\"remote_table\": \"" + mappedEntity + "\",\"column_mapping\": {" + derivedFromTo + "}}}}}";
  var response = await fetch(hasuraGraphqlEndpoint, {
        method: "POST",
        body: Caml_option.some(bodyString),
        headers: Caml_option.some(new Headers(headers))
      });
  var responseJson = await response.json();
  var statusCode = response.status;
  var $$case = validateHasuraResponse(statusCode, responseJson);
  if ($$case.TAG !== /* Ok */0) {
    return Logging.error({
                msg: "EE808: There was an issue setting up view permissions for the " + tableName + " table in hasura - indexing may still work - but you may have issues querying the data in hasura.",
                tableName: tableName,
                requestStatusCode: statusCode,
                requestResponseJson: responseJson
              });
  }
  var msg = $$case._0 ? "Hasura derived field permissions already created" : "Hasura derived field permissions created";
  return Logging.trace({
              msg: msg,
              tableName: tableName,
              requestStatusCode: statusCode,
              requestResponseJson: responseJson
            });
}

async function trackAllTables(param) {
  Logging.info("Tracking tables in Hasura");
  await clearHasuraMetadata(undefined);
  await trackTable("raw_events");
  await createSelectPermissions("raw_events");
  await trackTable("dynamic_contract_registry");
  await createSelectPermissions("dynamic_contract_registry");
  await trackTable("awesomeEntity");
  await createSelectPermissions("awesomeEntity");
}

exports.hasuraGraphqlEndpoint = hasuraGraphqlEndpoint;
exports.hasuraRole = hasuraRole;
exports.hasuraSecret = hasuraSecret;
exports.headers = headers;
exports.hasuraErrorResponse_encode = hasuraErrorResponse_encode;
exports.hasuraErrorResponse_decode = hasuraErrorResponse_decode;
exports.validateHasuraResponse = validateHasuraResponse;
exports.clearHasuraMetadata = clearHasuraMetadata;
exports.trackTable = trackTable;
exports.createSelectPermissions = createSelectPermissions;
exports.createEntityRelationship = createEntityRelationship;
exports.trackAllTables = trackAllTables;
/*  Not a pure module */
