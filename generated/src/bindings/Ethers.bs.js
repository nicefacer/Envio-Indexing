// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Spice = require("@greenlabs/ppx-spice/src/rescript/Spice.bs.js");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Ethers = require("ethers");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");

function unsafeToOption(unsafeFunc) {
  try {
    return Caml_option.some(Curry._1(unsafeFunc, undefined));
  }
  catch (raw__obj){
    var _obj = Caml_js_exceptions.internalToOCamlException(raw__obj);
    if (_obj.RE_EXN_ID === Js_exn.$$Error) {
      return ;
    }
    throw _obj;
  }
}

var Misc = {
  unsafeToOption: unsafeToOption
};

function fromString(str) {
  return unsafeToOption(function (param) {
              return BigInt(str);
            });
}

function toInt(b) {
  return Belt_Int.fromString(b.toString());
}

function add(a, b) {
  return (a + b);
}

function sub(a, b) {
  return (a - b);
}

function mul(a, b) {
  return (a * b);
}

function div(a, b) {
  return (b > 0n ? a / b : 0n);
}

function pow(a, b) {
  return (a ** b);
}

function mod(a, b) {
  return (b > 0n ? a % b : 0n);
}

function eq(a, b) {
  return (a === b);
}

function neq(a, b) {
  return (a !== b);
}

function gt(a, b) {
  return (a > b);
}

function gte(a, b) {
  return (a >= b);
}

function lt(a, b) {
  return (a < b);
}

function lte(a, b) {
  return (a <= b);
}

function shift_left(a, b) {
  return (a << b);
}

function shift_right(a, b) {
  return (a >> b);
}

function logor(a, b) {
  return (a | b);
}

function logand(a, b) {
  return (a & b);
}

var Bitwise = {
  shift_left: shift_left,
  shift_right: shift_right,
  logor: logor,
  logand: logand
};

function t_encode(bigint) {
  return bigint.toString();
}

function t_decode(json) {
  var stringBigInt = Js_json.decodeString(json);
  if (stringBigInt !== undefined) {
    var bigInt = unsafeToOption(function (param) {
          return BigInt(stringBigInt);
        });
    if (bigInt !== undefined) {
      return {
              TAG: /* Ok */0,
              _0: Caml_option.valFromOption(bigInt)
            };
    }
    var spiceErr = {
      path: "BigInt.t",
      message: "String not deserializeable to BigInt.t",
      value: json
    };
    return {
            TAG: /* Error */1,
            _0: spiceErr
          };
  }
  var spiceErr$1 = {
    path: "BigInt.t",
    message: "Json not deserializeable to string of BigInt.t",
    value: json
  };
  return {
          TAG: /* Error */1,
          _0: spiceErr$1
        };
}

var $$BigInt$1 = {
  fromString: fromString,
  toInt: toInt,
  add: add,
  sub: sub,
  mul: mul,
  div: div,
  pow: pow,
  mod: mod,
  eq: eq,
  neq: neq,
  gt: gt,
  gte: gte,
  lt: lt,
  lte: lte,
  Bitwise: Bitwise,
  t_encode: t_encode,
  t_decode: t_decode
};

function makeHumanReadableAbi(abiArray) {
  return abiArray;
}

function makeAbi(abi) {
  return abi;
}

function ethAddress_encode(ethAdress) {
  return ethAdress;
}

function ethAddress_decode(json) {
  var stringAddress = Js_json.decodeString(json);
  if (stringAddress !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: stringAddress
          };
  }
  var spiceErr = {
    path: "ethAddress",
    message: "Json not deserializeable to string of ethAddress",
    value: json
  };
  return {
          TAG: /* Error */1,
          _0: spiceErr
        };
}

function getAddressFromString(str) {
  return unsafeToOption(function (param) {
              return Ethers.ethers.getAddress(str);
            });
}

function ethAddressToString(address) {
  return address;
}

function ethAddressToStringLower(address) {
  return address.toLowerCase();
}

function blockTagFromSemantic(semanticTag) {
  return semanticTag;
}

function blockTagFromBlockNumber(blockNumber) {
  return blockNumber;
}

function blockTagFromHexString(hexString) {
  return hexString;
}

function blockTagFromVariant(variant) {
  if (typeof variant !== "number") {
    return variant._0;
  }
  switch (variant) {
    case /* Latest */0 :
        return "latest";
    case /* Earliest */1 :
        return "earliest";
    case /* Pending */2 :
        return "pending";
    
  }
}

var BlockTag = {
  blockTagFromSemantic: blockTagFromSemantic,
  blockTagFromBlockNumber: blockTagFromBlockNumber,
  blockTagFromHexString: blockTagFromHexString,
  blockTagFromVariant: blockTagFromVariant
};

var topic_encode = Spice.stringToJson;

var topic_decode = Spice.stringFromJson;

var EventFilter = {
  topic_encode: topic_encode,
  topic_decode: topic_decode
};

function filterFromRecord(filterRecord) {
  return filterRecord;
}

var Filter = {
  filterFromRecord: filterFromRecord
};

function combineEventFilters(eventFilters, fromBlock, toBlock) {
  var addresses = Belt_Array.reduce(eventFilters, [], (function (currentAddresses, filter) {
          var isNewAddress = !currentAddresses.includes(filter.address);
          if (isNewAddress) {
            return Belt_Array.concat(currentAddresses, [filter.address]);
          } else {
            return currentAddresses;
          }
        }));
  var topicsArr = Belt_Array.reduce(Belt_Array.keepMap(eventFilters, (function (filter) {
              return Belt_Array.get(filter.topics, 0);
            })), [], (function (currentTopics, topic) {
          var isNewFilter = !currentTopics.includes(topic);
          if (isNewFilter) {
            return Belt_Array.concat(currentTopics, [topic]);
          } else {
            return currentTopics;
          }
        }));
  return {
          address: addresses,
          topics: [topicsArr],
          fromBlock: fromBlock,
          toBlock: toBlock
        };
}

function combinedFilterToFilter(combinedFilter) {
  return combinedFilter;
}

var CombinedFilter = {
  combineEventFilters: combineEventFilters,
  combinedFilterToFilter: combinedFilterToFilter
};

function logToMinimumParseableLogData(prim) {
  return prim;
}

var PreparedTopicFilter = {};

var Network = {};

function makeStatic(rpcUrl, chainId) {
  var network = Ethers.Network.from(chainId);
  return new (Ethers.ethers.JsonRpcProvider)(rpcUrl, Caml_option.some(network), {
              staticNetwork: network
            });
}

function onBlock(t, callback) {
  t.on("block", callback);
}

function removeOnBlockEventListener(t) {
  t.off("block");
}

var JsonRpcProvider = {
  makeStatic: makeStatic,
  onBlock: onBlock,
  removeOnBlockEventListener: removeOnBlockEventListener
};

var EventFragment = {};

function parseLog($$interface, log) {
  try {
    var parsed = $$interface.parseLog(log);
    if (parsed == null) {
      return {
              TAG: /* Error */1,
              _0: /* EventNotFound */0
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: parsed
            };
    }
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    return {
            TAG: /* Error */1,
            _0: /* ParseError */{
              _0: e
            }
          };
  }
}

var Interface = {
  parseLog: parseLog
};

function getPreparedTopicFilter(contract, eventName) {
  return unsafeToOption(function (param) {
              return (contract.filters[eventName]());
            });
}

function getEventFilter(contract, eventName) {
  var address = contract.target;
  var topics = Belt_Option.mapWithDefault(getPreparedTopicFilter(contract, eventName), [], (function (preparedTopicFilter) {
          return [preparedTopicFilter.fragment.topicHash];
        }));
  return {
          address: address,
          topics: topics
        };
}

var Contract = {
  getPreparedTopicFilter: getPreparedTopicFilter,
  getEventFilter: getEventFilter
};

exports.Misc = Misc;
exports.$$BigInt = $$BigInt$1;
exports.makeHumanReadableAbi = makeHumanReadableAbi;
exports.makeAbi = makeAbi;
exports.ethAddress_encode = ethAddress_encode;
exports.ethAddress_decode = ethAddress_decode;
exports.getAddressFromString = getAddressFromString;
exports.ethAddressToString = ethAddressToString;
exports.ethAddressToStringLower = ethAddressToStringLower;
exports.BlockTag = BlockTag;
exports.EventFilter = EventFilter;
exports.Filter = Filter;
exports.CombinedFilter = CombinedFilter;
exports.logToMinimumParseableLogData = logToMinimumParseableLogData;
exports.PreparedTopicFilter = PreparedTopicFilter;
exports.Network = Network;
exports.JsonRpcProvider = JsonRpcProvider;
exports.EventFragment = EventFragment;
exports.Interface = Interface;
exports.Contract = Contract;
/* ethers Not a pure module */
